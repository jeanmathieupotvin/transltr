% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flatten.R
\name{flatten}
\alias{flatten}
\alias{flatten_tags}
\alias{unflatten}
\alias{print.Flat}
\alias{flat_read}
\alias{flat_write}
\title{Flatten Objects}
\usage{
flatten(x, tag_sep = ": ", tag_empty = "")

flatten_tags(x, tag_sep = ": ", tag_empty = "")

unflatten(string, tag_sep = ": ")

\method{print}{Flat}(x, ...)

flat_read(path = "", encoding = "UTF-8", tag_sep = ": ", keep_flat = FALSE)

flat_write(x, path = "", tag_sep = ": ", tag_empty = "")
}
\arguments{
\item{x}{Any \R object. Its elements must be coercible to a common
\link{atomic} type for \code{\link[=flatten]{flatten()}}.}

\item{tag_sep}{A non-empty and non-\link[base:NA]{NA} character string. The
separator to use when creating tags from names (recursively) extracted
from \code{x}.}

\item{tag_empty}{A non-\link[base:NA]{NA} character string. The value to use
as a substitute for empty names. Positional indices are automatically
appended to it to ensure tags are always unique.}

\item{string}{A non-\link[base:NA]{NA} character string. A \emph{flat} string to
unserialize.}

\item{...}{Further elements passed to, or from other methods.}

\item{path}{Passed as is to argument \code{path} of \code{\link[=text_read]{text_read()}}, or
\code{\link[=text_write]{text_write()}}.}

\item{encoding}{Passed as is to argument \code{encoding} of \code{\link[=text_read]{text_read()}}, or
\code{\link[=text_write]{text_write()}}.}

\item{keep_flat}{A non-\link[base:NA]{NA} logical value. Should the flat string
be kept and returned as an attribute?}
}
\value{
\code{\link[=flatten]{flatten()}} returns a character string of S3 class \code{\link[=flatten]{Flat}}.

\code{\link[=flatten_tags]{flatten_tags()}} returns a character vector.

\code{\link[=unflatten]{unflatten()}} and \code{\link[=flat_read]{flat_read()}} returns a named list, possibly empty. Its
structure depends on the underlying tags. If \code{keep_flat} is \code{TRUE},
\code{\link[=flat_read]{flat_read()}} attaches a \code{flat} attribute to the output. The latter is a
character string of S3 class \code{\link[=flatten]{Flat}}, which is the (unparsed)
flat string with comments removed.

\code{\link[=print]{print()}} returns argument \code{x} invisibly.

\code{\link[=flat_write]{flat_write()}} returns \code{NULL}, invisibly. It enforces \code{UTF-8} at all times.
Inputs are re-encoded if necessary.
}
\description{
Serialize \R objects into textual sequences of unindented (\emph{flat}) and
identifiable sections.
}
\details{
The Flat format is a minimal textual data serialization format optimized
for \link[=is.recursive]{recursive} objects. Elements of such objects are
converted to character strings and organized into unindented sections
identified by a tag. The resulting representation is called a \emph{flat string}.

\code{\link[=flatten]{flatten()}} produces flat strings which are objects of S3 class
\code{\link[=flatten]{Flat}}. The class is relevant for printing purposes only.

\code{\link[=unflatten]{unflatten()}} is the inverse operation: it unserializes flat strings
back into \R objects. The latter will have the exact same \emph{shape} as
the original object, but with elements coerced to character strings.

\code{\link[=flatten]{flatten()}} is similar to a \emph{melting process} (a \emph{wide-to-long}
transformation), where each element of a \link[=is.recursive]{recursive}
object is reformatted as a sequence of sections identified by a tag.
Tags may not be unique, depending on the input's structure and names.

\if{html}{\out{<hr>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Illustrating the Flat Format
#
# An octothorpe indicates that the underlying line is a comment.
# Comments are ignored by flat_read().

:: Tags

Tags always begin by two colons. They indicate the beginning of a section.

:: Tags: Creating Them

Tags are constructed from the names of the object being flattened.

:: Tags: <label>[3]

Missing names are substituted by a numbered standard label automatically.

:: Tags: <label>[3]: <label>[1]

The format handles any number of missing names, regardless of their depth
in the object being flattened.

:: Comments

# You may put comments anywhere, as long as they are on their own lines.

Inline comments are disallowed. # This is not a comment.
}\if{html}{\out{</div>}}

\if{html}{\out{<hr>}}

\code{\link[=flatten]{flatten()}} relies on \code{\link[=unlist]{unlist()}} to produce a character vector from a
\link{list}. However, unlike \code{\link[=unlist]{unlist()}} and \code{\link[=relist]{relist()}}, \code{\link[=flatten]{flatten()}} and
\code{\link[=unflatten]{unflatten()}}
\enumerate{
\item provide options to control how new names (\strong{tags}) are created,
\item natively allow flat strings to be reshaped back into the original
object (without requiring a \code{skeleton}), and
\item return a readily exportable textual output.
}
}
\keyword{internal}
