% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hash.R
\name{hash}
\alias{hash}
\alias{hash_algorithms}
\title{Hashing}
\usage{
hash(lang = "", text = "", algorithm = hash_algorithms())

hash_algorithms()
}
\arguments{
\item{lang}{A non-empty and non-\link[base:NA]{NA} character string. The
underlying language.

A language is usually a code (of two or three letters) for a native
language name. While users retain full control over codes, it is best
to use language codes stemming from well-known schemes such as
\href{https://en.wikipedia.org/wiki/IETF_language_tag}{IETF BCP 47}, or
\href{https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes}{ISO 639-1}
to maximize portability and cross-compatibility.}

\item{text}{A non-\link[base:NA]{NA} character string. It can be empty.}

\item{algorithm}{A non-empty and non-\link[base:NA]{NA} character string. The
algorithm to use when hashing \code{lang} and \code{text}. See Details. While it
should be equal to one of the values returned by \code{\link[=hash_algorithms]{hash_algorithms()}},
the first element of \code{algorithm} is passed as is to \code{\link[=switch]{switch()}} without
being validated for efficiency.}
}
\value{
\code{\link[=hash]{hash()}} returns a character string, or \code{NULL} if \code{algorithm} is not
supported (and \code{validate} is \code{FALSE}).

\code{\link[=hash_algorithms]{hash_algorithms()}} returns a character vector of length 2.
}
\description{
Map an arbitrary character string to globally unique, and reproducible
output.
}
\details{
Hashes uniquely identify the \code{lang} and \code{text} pair. Therefore, values
passed to these arguments are concatenated together (using \code{:} as the
separator), and \code{\link[=hash]{hash()}} generates a a reproducible hash from the resulting
character string.

\code{\link[=hash_algorithms]{hash_algorithms()}} returns available hashing algorithms. Methods are
described below.
\subsection{\code{SHA1}: Secure Hash Algorithm 1}{

Method \code{sha1} corresponds to SHA-1 (Secure Hash Algorithm version 1), a
cryptographic hashing function. While it is now superseded by more secure
variants (SHA-256, SHA-512, etc.), it is still useful for non-sensitive
purposes. It is fast, collision-resistant, and may handle very large inputs.
It emits strings of 40 hexadecimal characters.
}

\subsection{\code{UTF8}: Cumulative UTF-8 Sum}{

\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

\strong{This method is experimental. Use with caution.}

Method \code{utf8} is a simple method derived from cumulative sums of UTF-8 code
points (converted to integers). It is slightly faster than method \code{sha1} for
small inputs, and emits shorter hashes of a variable number of digits. The
length is porportional to the underlying input's length.

Strictly speaking, it is not a hashing algorithm per se. Instead, it
should be viewed as an identification algorithm that is highly likely to
produce different values for different inputs.
}
}
\note{
Further methods such as \href{https://github.com/Cyan4973/xxHash}{\code{xxhash}} will
be available in a near future.
}
\examples{
identical(
  hash("en", "Hello, world!", "sha1"),
  "256e0d707386d0fcd9abf10ad994000bdaa25812")

identical(hash("en", "Hello, world!", "utf8"), "12351")

hash_algorithms()

}
\seealso{
\code{\link{Translator}},
\code{\link{Text}},
\code{\link[=text_normalize]{text_normalize()}}
}
\keyword{internal}
