% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-location.R
\name{location}
\alias{location}
\alias{Location}
\alias{is_location}
\alias{format.Location}
\alias{print.Location}
\alias{c.Location}
\alias{merge_locations}
\alias{range_format}
\alias{range_parse}
\alias{range_is_parseable}
\title{Source Locations}
\usage{
location(path = tempfile(), line1 = 1L, col1 = 1L, line2 = 1L, col2 = 1L)

is_location(x)

\method{format}{Location}(x, ...)

\method{print}{Location}(x, ...)

\method{c}{Location}(...)

merge_locations(...)

range_format(x = location())

range_parse(ranges = character())

range_is_parseable(ranges = character())
}
\arguments{
\item{path}{A non-empty and non-\link[base:NA]{NA} character string. The origin
of the range(s).}

\item{line1, col1}{A non-empty integer vector of non-\link[base:NA]{NA} values.
The (inclusive) starting point(s) of what is being referenced.}

\item{line2, col2}{A non-empty integer vector of non-\link[base:NA]{NA} values.
The (inclusive) end(s) of what is being referenced.}

\item{x}{Any \R object. A \code{\link{Location}} object for \code{\link[=range_parse]{range_parse()}}.}

\item{...}{Usage depends on the underlying function.
\itemize{
\item Any number of \code{\link{Location}} objects for \code{\link[=merge_locations]{merge_locations()}}
and S3 method \code{\link[=c]{c()}}.
\item Further arguments passed to or from other methods for \code{\link[=format]{format()}} and
\code{\link[=print]{print()}}.
}}

\item{ranges}{A character vector of non-\link[base:NA]{NA} and non-empty values.
The ranges to extract pairs of indices (line, column) from. See Details.}
}
\value{
\code{\link[=location]{location()}}, and \code{\link[=c]{c()}} return a named list of length 5 and of S3 class
\code{\link{Location}} containing the values of \code{path}, \code{line1}, \code{col1},
\code{line2}, and \code{col2}.

\code{\link[=is_location]{is_location()}} returns a logical value.

\code{\link[=format]{format()}} returns a character vector.

\code{\link[=print]{print()}} returns argument \code{x} invisibly.

\code{\link[=merge_locations]{merge_locations()}} returns a list of (combined) \code{\link{Location}}
objects.

\code{\link[=range_format]{range_format()}} returns a character vector. It assumes that \code{x} is valid.

\code{\link[=range_parse]{range_parse()}} returns a list having the same length as \code{ranges}. Each
element is an integer vectors containing 4 non-\link[base:NA]{NA} values (unless
the underlying range is invalid).

\code{\link[=range_is_parseable]{range_is_parseable()}} returns a logical vector having the same length as
\code{ranges}.
}
\description{
Structure and manipulate source locations. Class \code{\link{Location}} is
a lighter alternative to \code{\link[=srcfile]{srcfile()}} and other related functionalities.
}
\details{
A \code{\link{Location}} is a set of one or more line/column ranges
referencing contents (like text or source code) within a common \emph{origin}
identified by an underlying \code{path}. The latter is generic and can be
\emph{anything}: a file on disk, on a network, a pointer, a binding, etc. What
matters is the underlying context.

\code{\link{Location}} objects may refer to multiple distinct ranges for
the the same origin. This is why arguments \code{line1}, \code{col1}, \code{line2} and
\code{col2} accept integer vectors (and not only scalar values).
\subsection{Combining Location Objects}{

\code{\link[=c]{c()}} can only combine \code{\link{Location}} objects having the same
\code{path}. In that case, the underlying ranges are combined into a set of
non-duplicated range(s).

\code{\link[=merge_locations]{merge_locations()}} is a generalized version of \code{\link[=c]{c()}} that handles any
number of \code{\link{Location}} objects having possibly different paths.
It can be viewed as a vectorized version of \code{\link[=c]{c()}}.
}

\subsection{Ranges}{

Ranges are \verb{Ln <int>, Col <int> @ Ln <int>, Col <int>} strings created on-the-fly from
\code{\link{Location}} objects for outputting purposes.

\code{\link[=range_format]{range_format()}}, \code{\link[=range_parse]{range_parse()}}, and \code{\link[=range_is_parseable]{range_is_parseable()}} are internal
functions respectively used to create, parse, and validate ranges.
}
}
\examples{
# Create Location objects.
loc1 <- location("file-a", 1L, 2L, 3L, 4L)
loc2 <- location("file-a", 5L, 6L, 7L, 8L)
loc3 <- location("file-c", c(9L, 10L), c(11L, 12L), c(13L, 14L), c(15L, 16L))

is_location(loc1)  ## TRUE

print(loc1)
print(loc2)
print(loc3)

# Combine Location objects.
# They must have the same path.
c(loc1, loc2)

# Otherwise, c() throws an error.
\dontrun{c(loc1, loc3)}

# Location objects with different paths can be merged.
# This groups Location objects according to their paths
# and calls c() on each group. It returns a list.
merge_locations(loc1, loc2, loc3)

# The path of a Location object can be whatever fits the context.
# Below is an example that references text in a character vector
# bound to variable x in the global environment.
x <- "This is a string and it is held in memory for some purpose."
location("<environment: R_GlobalEnv: x>", 1L, 11L, 1L, 16L)

# Create ranges, like format() does.
ranges <- range_format(loc3)

# Check whether ranges can be parsed (to integer vectors), and parse them.
range_is_parseable(ranges)
range_parse(ranges)

}
\keyword{internal}
