% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyze.R
\name{analyze-backend}
\alias{analyze-backend}
\alias{tokenize}
\alias{findBigStrings}
\alias{findCalls}
\alias{findCallEnd}
\alias{parseStream}
\alias{extractCallArgumentValue}
\title{Backend of the static analyzer}
\usage{
tokenize(file = character(1L))

findBigStrings(stream = character())

findCalls(stream = character(), name = "translate")

findCallEnd(stream = character(), start = integer(1L))

parseStream(stream = character())

extractCallArgumentValue(call, argName = "text", argPos = 1L)
}
\arguments{
\item{file}{A file path. It must point to an existing \R script.}

\item{stream}{A \emph{stream} of non-empty tokens created by \code{\link[=tokenize]{tokenize()}}.
See Details.}

\item{name}{A function's name.}

\item{start}{An index stating where to start in \code{stream} when \emph{traversing}
it (when looping through its elements).}

\item{call}{A \link[base:call]{call}.}

\item{argName}{Expected name of a function's argument.}

\item{argPos}{Expected position of a function's argument (in the underlying
\link[base:call]{call}).}
}
\value{
\code{\link[=tokenizer]{tokenizer()}} returns a character vector of non-empty, non-\link[base:NA]{NA}
values. It attaches the following attributes to it:

\item{\code{file}}{Path to the underlying \R script. See \code{file} above.}
\item{\code{workingDir}}{Current working directory.}
\item{\code{encoding}}{Encoding of \code{file}.}
\item{\code{timeStamp}}{Last time \code{file} was modified in Coordinated Universal
Time (UTC).}
\item{\code{locations}}{The \code{locations} of calls made to \code{name} in \code{file}.
The format is \code{"Ln X, Col Y"}, where \code{X} and \code{Y} are positive
integers.}

All these attributes are later passed down to the output of \code{\link[=analyze]{analyze()}}.
They stem from the underlying \link[base:srcfile]{srcfile} object returned
by \code{\link[base:parse]{base::parse()}} and from further attached information when \code{keep.source}
is \code{TRUE}.

\code{\link[=findBigStrings]{findBigStrings()}} and \code{\link[=findCalls]{findCalls()}} return an integer vector.

\code{\link[=findCallEnd]{findCallEnd()}} returns a single integer value.

\code{\link[=parseStream]{parseStream()}} returns a \link[base:is.language]{language} object. This
will typically be a \link[base:call]{call} but could also be something \emph{else}
(an \link[base:expression]{È©xpression}, a \link[base:name]{symbol}, etc.)
depending on the underlying \code{stream}.

\code{\link[=extractCallArgumentValue]{extractCallArgumentValue()}} may return \emph{almost} anything, depending on the
context: a \link[base:is.language]{language} object, an
\link[base:vector]{atomic} vector, etc. It is expected that it returns a
single character value when \code{name}, \code{argName}, and \code{argPos} are respectively
equal to \code{"translate"}, \code{"text"}, and \code{1L}.
}
\description{
These functions are internally used by function \code{\link[=analyze]{analyze()}}. They should
not be used elsewhere.
}
\details{
The internal engine relies on \code{\link[base:parse]{base::parse()}} to decompose \R code into
sequences of \emph{tokens} (single elements of the language). For more information
on \R tokens, see \code{\link[utils:getParseData]{utils::getParseData()}}.
}
\section{Structure}{

The engine has a single entry point: \code{\link[=analyze]{analyze()}}. It assembles individual
parts described here. It mainly goes through the steps described in section
\emph{Note} of the latter.

#FIXME: TO BE COMPLETED.
}

\keyword{internal}
