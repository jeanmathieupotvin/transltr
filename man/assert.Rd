% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assert.R
\name{is_int}
\alias{is_int}
\alias{is_chr}
\alias{is_lgl1}
\alias{is_int1}
\alias{is_chr1}
\alias{is_list}
\alias{is_between}
\alias{is_named}
\alias{is_match}
\alias{assert_int}
\alias{assert_chr}
\alias{assert_lgl1}
\alias{assert_int1}
\alias{assert_chr1}
\alias{assert_list}
\alias{assert_between}
\alias{assert_named}
\alias{assert_match}
\alias{assert_arg}
\title{Test Objects}
\usage{
is_int(x, allow_empty = FALSE)

is_chr(x, allow_empty = FALSE)

is_lgl1(x)

is_int1(x)

is_chr1(x, allow_empty_string = FALSE)

is_list(x, allow_empty = FALSE)

is_between(x, min = -Inf, max = Inf)

is_named(x, allow_empty_names = FALSE, allow_na_names = FALSE)

is_match(x, choices, allow_partial = FALSE)

assert_int(
  x,
  allow_empty = FALSE,
  throw_error = TRUE,
  x_name = deparse(substitute(x))
)

assert_chr(
  x,
  allow_empty = FALSE,
  throw_error = TRUE,
  x_name = deparse(substitute(x))
)

assert_lgl1(x, throw_error = TRUE, x_name = deparse(substitute(x)))

assert_int1(x, throw_error = TRUE, x_name = deparse(substitute(x)))

assert_chr1(
  x,
  allow_empty_string = FALSE,
  throw_error = TRUE,
  x_name = deparse(substitute(x))
)

assert_list(
  x,
  allow_empty = FALSE,
  throw_error = TRUE,
  x_name = deparse(substitute(x))
)

assert_between(
  x,
  min = -Inf,
  max = Inf,
  throw_error = TRUE,
  x_name = deparse(substitute(x))
)

assert_named(
  x,
  allow_empty_names = FALSE,
  allow_na_names = FALSE,
  throw_error = TRUE,
  x_name = deparse(substitute(x))
)

assert_match(
  x,
  choices,
  allow_partial = FALSE,
  quote_values = FALSE,
  throw_error = TRUE,
  x_name = deparse(substitute(x))
)

assert_arg(x, quote_values = FALSE, throw_error = TRUE)
}
\arguments{
\item{x}{An object to be tested.}

\item{allow_empty}{Should empty vectors of length 0 be considered as
valid values?}

\item{allow_empty_string}{Should empty character strings be considered as
valid values?}

\item{min}{A numeric lower bound. It can be infinite.}

\item{max}{A numeric upper bound. It can be infinite.}

\item{allow_empty_names}{Should empty character strings be considered as
valid names? Note that this is different from having no names at all.}

\item{allow_na_names}{Should NA values be considered as valid names?}

\item{choices}{A \link[base:vector]{vector} of valid candidates for \code{x}.}

\item{allow_partial}{Should \code{x} be partially matched? If so,
\code{\link[base:pmatch]{base::pmatch()}} is used. Note that \code{\link[base:match]{base::match()}} is used by default.
The former is used to mimic the behavior of \code{\link[base:match.arg]{base::match.arg()}}.}

\item{throw_error}{Should an error be thrown? If so, they are returned
by \code{\link[=stops]{stops()}}.}

\item{x_name}{The underlying name of \code{x}.}

\item{quote_values}{Should \code{choices} be quoted with single quotation marks?}
}
\value{
\code{\link[=is_int]{is_int()}},
\code{\link[=is_chr]{is_chr()}},
\code{\link[=is_lgl1]{is_lgl1()}},
\code{\link[=is_int1]{is_int1()}},
\code{\link[=is_chr1]{is_chr1()}},
\code{\link[=is_list]{is_list()}},
\code{\link[=is_between]{is_between()}},
\code{\link[=is_named]{is_named()}}, and
\code{\link[=is_match]{is_match()}} all return a logical value.

\code{\link[=assert_int]{assert_int()}},
\code{\link[=assert_chr]{assert_chr()}},
\code{\link[=assert_lgl1]{assert_lgl1()}},
\code{\link[=assert_int1]{assert_int1()}},
\code{\link[=assert_chr1]{assert_chr1()}},
\code{\link[=assert_list]{assert_list()}},
\code{\link[=assert_between]{assert_between()}},
\code{\link[=assert_named]{assert_named()}},
\code{\link[=assert_match]{assert_match()}},
\code{\link[=assert_arg]{assert_arg()}} all return an empty character string if \code{x} meets the
underlying condition(s) specified by the function. Otherwise, they
throw an error unless \code{throw_error} is \code{FALSE}. In that case, the
error message is returned as a character string.
}
\description{
Functions below internally streamline usage of defensive programming
through \emph{functional guard clauses} (guard clauses as functions).

\verb{is_*()} functions check whether their argument meets condition(s) and
always returns a logical. Each \verb{is_*()} function has a corresponding
\verb{assert_*()} function that further throws an error message when these
condition(s) are not met.
}
\details{
Guard clauses are quite useful when writing more robust code. However, they
tend to be verbose and recycled within a project. Manually copying them
multiple times makes it harder to keep error messages consistent over
time. The \verb{assert_*()} family solves these challenges by encapsulating
guard clause into simple semantic functions. See Examples below.

By convention, \link[base:NA]{NA} values are \strong{always} disallowed. This is
because \code{\link{transltr}} rarely uses them.
}
\note{
\code{\link[=assert_arg]{assert_arg()}} is a refactoring of \code{\link[base:match.arg]{base::match.arg()}} and relies on
\code{\link[=assert_match]{assert_match()}} internally and does not have a direct \code{is_arg()}
equivalent. It is designed to be called within another function.
}
\examples{
x <- "my string"

## Here is a guard clause that checks whether an input is a character
## string. While this works fine, having to deal with many similar
## structures across the whole project is cumbersome.
if (!is.character(x) || length(x) != 1L || !nzchar(x) || is.na(x)) {
    stop("'x' must be a must be a non-NA and non-empty character of length 1.")
}

## The call to if () can be simplified with is_chr1().
if (!transltr:::is_chr1(x, allow_empty_string = FALSE)) {
    stop("'x' must be a must be a non-NA and non-empty character of length 1.")
}

## The whole structure can be replaced by a single call to assert_chr1().
transltr:::assert_chr1(x)

}
\seealso{
\code{\link[=stops]{stops()}}
}
\concept{assert}
\concept{is}
\keyword{internal}
