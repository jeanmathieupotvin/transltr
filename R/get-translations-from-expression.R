#' Find translations in an expression
#'
#' @description
#' Find and extract strings to be translated at runtime and passed to
#' [translate()] in an [expression][base::expression] vector. Strings
#' are automatically concatenated together before being returned.
#'
#' Functions below are considered low-level and should not be used by end
#' users. This documentation is intended for developers.
#'
#' @param expr an [expression][base::expression].
#'
#' @param call a [call][base::call] to [translate()] or to the double
#' colon operator (`::`). For the latter, arguments `pkg` and `name`
#' must respectively be set equal to `transltr` and `translate`.
#'
#' @param env an [environment][base::environment].
#'
#' @param x an \R object to be tested.
#'
#' @details
#' [getTranslationsFromExpression()] is the internal *main* mechanism. All
#' other functions here are helper functions called by the former.
#'
#' Each extracted string is uniquely identified by a string created by
#' [.getStringId()]. Identifiers are considered to be collision-resistant.
#'
#' ## Implicit and explicit calls
#'
#' An [expression][base::expression] may contain [call][base::call] object(s):
#' a [mode][base::mode] representing an unevaluated function expression applied
#' to the given arguments.
#'
#' [.isTranslateCall()] detects [calls] made to [translate()]. There are two
#' possibilities. A call that depends on the [search][base::search()] path is
#' said to be *implicit*. A call that directly refers this package it is said
#' to be *explicit*.
#'
#' ```
#' translate("hello, world!")                 # implicit
#' cat(translate("hello, world!"))            # implicit
#' transltr::translate("hello, world!")       # explicit
#' cat(transtlr::translate("hello, world!"))  # explicit
#' ```
#'
#' Implicit calls to [translate()] are discouraged because they are considered
#' to be a bad coding practice.
#'
#' @returns
#' * [getTranslationsFromExpression()] returns a named list (possibly empty).
#'   Elements are also named lists containing 2 elements: extracted `string`
#'   and its `id`. Names of the *outer* list match `id` values.
#'
#' * [.getStringFromTranslateCall()] returns `env` invisibly and assigns
#'   a new value to it if applicable. Its name is given by [.getStringId()].
#'
#' * [.getStringId()] returns a string of 32 hexadecimal characters. It
#'   corresponds to a BLAKE2b hash of 16 bytes generated by [sodium::hash()].
#'
#' * [.isTranslateCall()],
#'   [.isImplicitTranslateCall()], and
#'   [.isExplicitTranslateCall()] all return `TRUE` if `call` is a
#'   [call][base::call] to [translate()] and `FALSE` othwerwise.
#'   See Details and Examples for more information.
#'
#' @examples
#' implicitCall <- call("translate", "hello, world!")
#' explicitCall <- str2lang("transltr::translate(\"hello, world!\")")
#'
#' .isTranslateCall(implicitCall)          # TRUE
#' .isTranslateCall(explicitCall)          # TRUE
#'
#' .isImplicitTranslateCall(implicitCall)  # TRUE
#' .isImplicitTranslateCall(explicitCall)  # FALSE
#'
#' .isExplicitTranslateCall(implicitCall)  # FALSE
#' .isExplicitTranslateCall(explicitCall)  # TRUE
#'
#' expr1 <- str2lang("transltr::translate(\"hello, \", \"world!\", lang = \"en\")")
#' getTranslationsFromExpression(expr1)
#'
#' expr2 <- str2lang("translate(\"hello, \", \"world!\")")
#' getTranslationsFromExpression(expr2)
#'
#' identical(.getStringId("hello, world!"), "fcb655f3a969048c07294cfa7ef53af4")
#'
#' @author Jean-Mathieu Potvin (<jeanmathieupotvin@@ununoctium.dev>)
#'
#' @seealso [sodium::hash()]
#'
#' @rdname get-translations-from-expresssion
#'
#' @keywords internal
getTranslationsFromExpression <- function(expr = expression()) {
    # Recurse into (possibly embedded)
    # expressions and register strings
    # extracted from matched calls to
    # translate() in env.
    .getTranslationsFromExpression <- function(expr, env) {
        if (.isTranslateCall(expr)) {
            .getStringFromTranslateCall(expr, env)
        }
        if (is.recursive(expr)) {
            for (i in seq_along(expr)) {
                Recall(expr[[i]], env)
            }
        }

        return(invisible(env))
    }

    env <- new.env(parent = emptyenv())
    return(as.list(.getTranslationsFromExpression(expr, env), sorted = TRUE))
}

#' @rdname get-translations-from-expresssion
#' @keywords internal
.getStringFromTranslateCall <- function(call, env) {
    # First argument in args is always the name of the
    # called function. We drop it because we only need
    # supplied arguments passed to ...
    dots <- as.list(match.call(translate, call))[-1L]

    # Remove arguments that matches formal
    # arguments of translate(). Remaining
    # arguments were passed to ...
    if (!is.null(dotsNames <- names(dots))) {
        dots <- dots[is.na(match(dotsNames, names(formals(translate)), NA))]
    }

    string <- paste0(dots, collapse = "")
    id     <- .getStringId(string)

    # Identical string(s) have same hash/id and
    # therefore appear once by design in env.
    assign(id, list(string = string, id = id), env)
    return(invisible(env))
}

#' @rdname get-translations-from-expresssion
#' @keywords internal
.getStringId <- function(string = character(1L)) {
    return(sodium::bin2hex(sodium::hash(charToRaw(string), size = 16L)))
}

#' @rdname get-translations-from-expresssion
#' @keywords internal
.isTranslateCall <- function(x) {
    return(.isImplicitTranslateCall(x) || .isExplicitTranslateCall(x))
}

#' @rdname get-translations-from-expresssion
#' @keywords internal
.isImplicitTranslateCall <- function(x) {
    return(
        is.call(x) &&                      # x is a call
        is.name(x[[1L]]) &&                # x refers valid symbol
        deparse1(x[[1L]]) == "translate")  # x refers translate()
}

#' @rdname get-translations-from-expresssion
#' @keywords internal
.isExplicitTranslateCall <- function(x) {
    return(
        is.call(x) &&                             # x is a call
        is.call(x[[1L]]) &&                       # x refers a sub-call
        is.name(x[[1L]][[1L]]) &&                 # sub-call refers valid symbol
        deparse1(x[[1L]][[1L]]) == "::" &&        # sub-call refers operator ::
        is.name(x[[1L]][[2L]]) &&                 # sub-call refers valid symbol
        deparse1(x[[1L]][[2L]]) == "transltr" &&  # sub-call refers this package
        is.name(x[[1L]][[3L]]) &&                 # sub-call refers valid symbol
        deparse1(x[[1L]][[3L]]) == "translate")   # sub-call refers translate()
}
